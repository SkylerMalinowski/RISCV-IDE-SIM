/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options{
  STATIC = false;              // Default: true
  IGNORE_CASE = true;          // Default: false
  USER_CHAR_STREAM = false;    // Default: false
  USER_TOKEN_MANAGER = false;  // Default: false
  DEBUG_PARSER = true;         // Default: false}PARSER_BEGIN(Parser)package assembler;

import java.io.*;
import java.util.*;

public class Parser{
  public static void theThing(String filePath)
  {
    try
    {
      Parser parser = new Parser(new FileInputStream(filePath));
      parser.Analyze();
    }
    catch (Exception e)
    {
      System.out.println("NOK.");
      System.out.println(e.getMessage());
      //System.exit(0);
    }
    catch (Error e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      //System.exit(0);
    }
  }

  /**
   * Deep Error Recovery :: If an exception is thrown, reset parsing to the given @param after the error.
   * @param kind : TOKEN or element
   */
  void SkipTo (int kind)
  {
    ParseException e = generateParseException();
    System.out.println(e.toString());

    // Skip to kind
    ///*
    Token t;
    do {
      t = getNextToken();
    } while (t.kind != kind);
    //*/

    // Skip to one before kind
    /*
    Token t = getToken(0);
    while (t.next.kind != EOF && t.next.kind != kind) {
      t = getNextToken();
    }
    */
  }
    public static void main(String args []) throws ParseException  {
    try
    {
      Parser parser = new Parser(System.in);
      System.out.println("Reading from standard input...");
      System.out.print("Enter code : ");
      parser.Analyze();
    }
    catch (Exception e)
    {
      System.out.println("NOK.");
      System.out.println(e.getMessage());
      //Parser.ReInit(System.in);
      System.exit(0);
    }
    catch (Error e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      System.exit(0);
    }
  }}PARSER_END(Parser)
/**
 * Token Declarations
 */
SKIP : /* WHITESPACE */{  " "   // space| "\t"  // tab
}

SKIP : /* END OF LINE, ESCAPE SEQUENCE */
{
  < EOL : ("\n"|"\r")+ >
}

SKIP : /* COMMENT */
{
  < COMMENT : "#" (~["\r","\n","\f"])* ("\r"|"\n"|"\f")+ >
}

TOKEN : /* SYMBOL */{
  < COMMA : "," >
| < L_PAREN : "(" >
| < R_PAREN : ")" >
| < PLUS : "+" >
| < MINUS : "-" >
}

TOKEN : /* RISC-V */
{  < REGISTER : "x" (<NUMERIC>) >
| < DIRECTIVE : "." (<ALPHA>) >
| < LABEL : (<ALPHA>) ":" >
| < STRING : "\"" (~["\""])+ "\"" >
}
TOKEN : /* INSTRUCTIONS */
{
  < INSTRUCTION : <ALPHA> >
}
TOKEN : /* ALPHA NUMERIC */
{
  < ALPHA : (<LETTER>|"_")+ >
| < #LETTER : ["a"-"z","A"-"Z"] >
| < NUMERIC : (<DECIMAL>|<HEXADECIMAL>|<OCTAL>|<BINARY>) >
| < DECIMAL : (<DECI_DIGIT>)+ >
| < HEXADECIMAL : ("0x"|"0X") (<HEX_DIGIT>)+ >
| < OCTAL : ("0o"|"0O") (<OCT_DIGIT>)+ >
| < BINARY : ("0b"|"0B") (<BIN_DIGIT>)+ >
| < #DECI_DIGIT : ["0"-"9"] >
| < #HEX_DIGIT : (["0"-"9","a"-"f","A"-"F"]) >
| < #OCT_DIGIT : ["0"-"7"] >
| < #BIN_DIGIT : ["0","1"] >
| < FLOATING_NUMERIC : (<DECIMAL_FLOAT>|<HEXADECIMAL_FLOAT>|<OCTAL_FLOAT>|<BINARY_FLOAT>) >
| < DECIMAL_FLOAT : (<DECI_DIGIT>)+ "." (<DECI_DIGIT>)* ((<EXPONENT>) (<DECI_DIGIT>)+)? >
| < HEXADECIMAL_FLOAT : ("0x"|"0X") (<HEX_DIGIT>)+ "." (<HEX_DIGIT>)* ((<EXPONENT>) (<HEX_DIGIT>)+)? >
| < OCTAL_FLOAT : ("0o"|"0O") (<OCT_DIGIT>)+ "." (<OCT_DIGIT>)* ((<EXPONENT>) (<OCT_DIGIT>)+)? >
| < BINARY_FLOAT : ("0b"|"0B") (<BIN_DIGIT>)+ "." (<BIN_DIGIT>)* ((<EXPONENT>) (<BIN_DIGIT>)+)? >
| < #EXPONENT: ("p"|"P") (["+","-"])? >}

TOKEN :
{
  < OTHER : ~[] >
}

// TODO : token states for instruction types, braces, bases, and extensions

/**
 * Function Declarations
 */

// TODO : make custom error reporting
void Analyze() :
{  }
{
  try
  {
    (
      Label()
    | Directive()
    | Instruction()
    )*
  }
  catch (ParseException e)
  {
    System.out.println(e.toString());
    SkipTo(EOL);
  }
}

void Label() :
{  }
{
  <LABEL>
}

// TODO : more directive tokens for robust directive detection
// "https://github.com/riscv/riscv-asm-manual/blob/master/riscv-asm.md" :: directives
void Directive() :
{  }
{
  <DIRECTIVE> <ALPHA>
}

void Instruction() :
{  }
{
  /*
  LOOKAHEAD(6) U_Type()| LOOKAHEAD(6) S_Type()
| LOOKAHEAD(6) R_Type()
| LOOKAHEAD(6) I_Type()
| LOOKAHEAD(6) B_Type()
  */
}

void R_Type() : 
{  }
{
  <INSTRUCTION> <REGISTER> (<COMMA>)? <REGISTER> (<COMMA>)? <REGISTER>
}

void I_Type() : 
{  }
{
  <INSTRUCTION> <REGISTER> (<COMMA>)? <REGISTER> (<COMMA>)? <NUMERIC>
}

void S_Type() : 
{  }
{
  <INSTRUCTION> <REGISTER> (<COMMA>)? (<NUMERIC>|<REGISTER>)? <L_PAREN> <REGISTER> <R_PAREN>
}

void B_Type() : 
{  }
{
  <INSTRUCTION> <REGISTER> (<COMMA>)? <REGISTER> (<COMMA>)? <ALPHA>
}

void U_Type() : 
{  }
{
  <INSTRUCTION> <REGISTER> (<COMMA>)? (<NUMERIC>|<ALPHA>)
}
